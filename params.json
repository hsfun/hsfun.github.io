{"name":"GDB+assembly for understanding binaries","tagline":"","body":"# GDB+Assembly for understanding binaries.\r\n\r\nSometimes, it's handy to step through some compiled code, and source-level debugging won't cut it - maybe  you don't have the source, or it's in several programming languages. Most recently, [Julia](http://jvns.ca/) pointed out a capture-the-flag site, [zeromutarts](http://zeromutarts.de/), which has a small reverse-engineering challenge, called 'serial'. If you sign up, you can download the binary and follow along with this post.\r\n\r\nSo: how do you start with something like this? The first thing I do is disassemble the binary:\r\n<objdump -d serial > serial.s>. It looks something like this:\r\n```\r\nserial:     file format elf32-i386\r\nDisassembly of section .init:\r\n080482f4 <_init>:\r\n 80482f4:       53                      push   %ebx\r\n 80482f5:       83 ec 08                sub    $0x8,%esp\r\n 80482f8:       e8 b3 00 00 00          call   80483b0 <__x86.get_pc_thunk.bx>\r\n....\r\n <main>:\r\n 804847d:       55                      push   %ebp\r\n 804847e:       89 e5                   mov    %esp,%ebp\r\n 8048480:       83 e4 f0                and    $0xfffffff0,%esp\r\n 8048483:       83 ec 30                sub    $0x30,%esp\r\n 8048486:       c7 04 24 80 86 04 08    movl   $0x8048680,(%esp)\r\n 804848d:       e8 ae fe ff ff          call   8048340 <puts@plt>\r\n....\r\n```\r\n\r\nYou can clearly see the main function (and its address, 0x0804847d), as well as a lot of other supporting code, such as _init, which come from glibc rather than the application's programmer. A typical line looks like this:\r\n` 804847d:       55                      push   %ebp`\r\nThe first field is the address, the second is how it's actually represented in the binary, and the third is a [mnemonic](http://en.wikipedia.org/wiki/Assembly_language) representation, which is more human-friendly than the raw numbers. People usually write in assembly with mnemonics. \r\n\r\nSo, let's load this binary into gdb:\r\n`gdb serial`\r\nIt's handy to see what the current instruction is, so within gdb, run:\r\n`display /i $pc`, and then set a breakpoint at main to start looking at the interesting parts, rather than all the glibc setup: `break main`, then type `run` to start the program. You'll see something like this:\r\n```\r\n(gdb) run\r\nStarting program: /yourpath/serial\r\n\r\nBreakpoint 1, 0x08048480 in main ()\r\n1: x/i $pc\r\n=> 0x8048480 <main+3>:  and    $0xfffffff0,%esp\r\n```\r\nIf you've seen x86 assembly before, especially under Windows, the formatting may surprise you: objdump and gdb use [AT&T, rather than Intel, syntax](http://asm.sourceforge.net/articles/linasm.html). The biggest difference is that an instruction like `mov %esp,%ebp` copies the contents of the register esp into ebp, rather than vice versa. If you're used to intel syntax, run `set disassembly-flavor intel` in gdb and you'll see familiar forms like `mov ebp, esp` and `mov DWORD PTR [esp],0x8048680` instead.  The rest of this document will keep using AT&T syntax.\r\n\r\nIf you've debugged with gdb before, you probably know the 'n' and 's' commands, which execute the next line. N steps over function calls, while s steps into the. They have instruction-level equivalents, ni and si. If you want to dig into the actual assembly code for, say, malloc or printf, feel free to use si, but ni is a lot more convenient for a program like this, as it lets you ignore their implementations.\r\n\r\n```\r\n(gdb) ni\r\n0x08048483 in main ()\r\n1: x/i $pc\r\n=> 0x8048483 <main+6>:  sub    $0x30,%esp\r\n(gdb) ni\r\n0x08048486 in main ()\r\n1: x/i $pc\r\n=> 0x8048486 <main+9>:  movl   $0x8048680,(%esp)\r\n```\r\n\r\nThere are a few more handy tricks.\r\nSee the value of the registers:\r\n```\r\n(gdb) info registers\r\neax            0x1      1\r\necx            0xffffd6d4       -10540\r\nedx            0x804847d        134513789\r\nebx            0xf7fac000       -134561792\r\nesp            0xffffd600       0xffffd600\r\nebp            0xffffd638       0xffffd638\r\nesi            0x0      0\r\nedi            0x0      0\r\neip            0x8048486        0x8048486 <main+9>\r\neflags         0x286    [ PF SF IF ]\r\ncs             0x23     35\r\nss             0x2b     43\r\nds             0x2b     43\r\nes             0x2b     43\r\nfs             0x0      0\r\ngs             0x63     99`\r\n```\r\n\r\nBreak on a memory address, symbolically or numerically: ` break *main+0x9` or `break *0x8048486`. This is really handy when you've figured out that that address is something interesting, and you want to run or rerun the program and up at that exact point at a gdb prompt.\r\n\r\nYou can also inspect the value of one particular register, change it, and inspect it again:\r\n```\r\n(gdb) info registers eax\r\neax            0x3      3\r\n(gdb) set $eax = 5\r\n(gdb) info registers eax\r\neax            0x5      5\r\n```\r\n\r\nHave fun.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}